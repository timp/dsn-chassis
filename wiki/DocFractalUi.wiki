#summary documentation of the Fractal UI MVC pattern and supporting GWT library.

= Fractal UI =

<wiki:toc/>

== Introduction ==

Fractal UI is a architectural pattern for developing pure client-side (i.e., in-browser) applications, with supporting libraries for GWT. The design goals for Fractal UI are:

  * to enable an application to be developed in small, bite-size pieces, that are not overly complex or mind-bendingly hard to understand
  * to enable an application to grow in complexity without becoming difficult to maintain, test or debug
  * to enable different components of the application to be cleanly encapsulated, so that different members of a development team can work on different components in parallel, without disrupting each other's code or creating a tangled mess
  * to provide a clean separation of concerns that enables fine-grained unit testing 
  * to enable as much as possible of the application to be developed test-first

The name "fractal" is tentatively chosen because it provides a loose metaphor for the pattern. A fractal is self-similar, in that each of its parts, when examined more closely, appears similar to the whole. 

The Fractal UI pattern defines a strict internal MVC architecture for each component of an application, including the application itself. Each user-interface component's internal MVC architecture follows a strict execution cycle whereby events generated by user-interaction with the browser's DOM are mapped by the component's *event handlers* onto method calls on a *controller*. The component's *controller* performs some action (e.g., fetching or updating data asynchronously) before updating the components *model*. The component's *renderer* listens for changes to the *model* and updates the component's portion of the DOM (i.e., the component's *view*).

In addition to it's own internal MVC architecture, each user-interface component can also have nested user-interface components (children). Those nested components have the self-similar internal MVC architecture, and can themselves have nested components. Messages can propagate both up and down the hierarchy of nested components, providing a framework for coordination of behaviour between several components. 

== Fractal UI Components - Internal MVC Architecture ==

The Fractal MVC pattern defines an internal architecture for each user-interface component in the application. Each component has a *controller*, a *model*, a *renderer* and a set of *event handlers*, in addition to some portion of the browser's DOM, which constitutes the component's *view*. 

The pattern also requires that execution flows in a strict cycle, beginning with events generated by user interaction with the browser's DOM (the *view*), which are received by *event handlers*, which invoke some method on the *controller*, which performs some action and updates the *model*. The *renderer* listens for changes to the *model*, and updates the DOM to reflect those changes. 

http://farm3.static.flickr.com/2556/3771234129_55121daf90_d.jpg

One of the main advantages of the pattern is that it allows isolation of different aspects of the widget's logic. For example, the controller's logic can be tested by invoking methods on the controller, then examining the state of the model. I.e., the controller's logic, which is independent of any presentation details, can be isolated. Similarly, the renderer's logic can be tested by changing the state of the model, then examining the state of specitific user-interface elements.

By mandating that execution flow in the strict cycle described above, the pattern also avoids "spaghetti code" which becomes difficult to maintain as the complexity of a user-interface grows.

To illustrate the pattern with GWT, consider a very simple calculator application. The application itself is deployed at the following location:

  * [http://dsn-chassis.googlecode.com/svn/trunk/gwt/lib/war/examples/calculator.html example calculator application]
  
All of the source code for this application can be browsed from the following location:

  * [http://code.google.com/p/dsn-chassis/source/browse/#svn/trunk/gwt/lib/examples/examples/calculator browse calculator application source code]
  
=== Controller ===

The first step in developing this application was to define the [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/widget/Controller.java Controller] and [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/widget/Model.java Model] APIs. 

The `Controller` class has a single `calculate` method, which parses a string as a simple arithmetic calculation (e.g., "61-19"), executes the calculation, and stores the result in a property called `result` on the `Model`. 

{{{
package examples.calculator.client.widget;

class Controller {
        
        private static final String ADDITION = "\\s*(\\d+)\\s*\\+\\s*(\\d+)\\s*";
        private static final String SUBTRACTION = "\\s*(\\d+)\\s*-\\s*(\\d+)\\s*";
        private static final String MULTIPLICATION = "\\s*(\\d+)\\s*\\*\\s*(\\d+)\\s*";
        private static final String DIVISION = "\\s*(\\d+)\\s*/\\s*(\\d+)\\s*";
        private static final String OPERATORS = "[+*/\\-]"; 
        private Model model;

        Controller(Model model) {
                this.model = model;
        }

        void calculate(String calculation) throws SyntaxException {

                Double result = null;

                String[] args = calculation.split(OPERATORS);
                
                if (calculation.matches(ADDITION)) {
                        result = Double.parseDouble(args[0]) + Double.parseDouble(args[1]);
                } 
                else if (calculation.matches(SUBTRACTION)) {
                        result = Double.parseDouble(args[0]) - Double.parseDouble(args[1]);
                }
                else if (calculation.matches(MULTIPLICATION)) {
                        result = Double.parseDouble(args[0]) * Double.parseDouble(args[1]);
                }
                else if (calculation.matches(DIVISION)) {
                        result = Double.parseDouble(args[0]) / Double.parseDouble(args[1]);
                }
                else {
                        throw new SyntaxException("invalid syntax: "+calculation);
                }
                
                model.setResult(result);
        }

}
}}}

The `Model` class is very much like a Bean, in the sense that it has a set of properties and getters and setters for those properties, but no other behaviour.

{{{
package examples.calculator.client.widget;

import java.util.ArrayList;
import java.util.List;

class Model {

        private Double result = null;
        private List<ModelListener> listeners = new ArrayList<ModelListener>();
       
        Double getResult() {
                return result;
        }

        void setResult(Double to) {
                Double from = this.result;
                this.result = to;
                for (ModelListener listener : listeners) {
                        listener.onResultChanged(from, to);
                }
        }
       
        void addListener(ModelListener listener) {
                listeners.add(listener);
        }

}
}}}

The `Controller` and `Model` classes can be developed test-first, using a plain JUnit test case. The class [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/widget/TestController.java TestController] illustrates a unit test for the `Controller.calculate()` method. 

{{{
package examples.calculator.client.widget;

import static org.junit.Assert.*;
import org.junit.Test;

public class TestController {

        @Test
        public void testCalculate() throws Exception {
                
                Model model = new Model();
                Controller controller = new Controller(model);
                
                // check initial state of model
                assertNull(model.getResult());
                
                String calculation;
                
                // try integer addition
                calculation = "2+4";
                controller.calculate(calculation);
                assertEquals(6, model.getResult());
                
                // try integer subtraction
                calculation = "5-3";
                controller.calculate(calculation);
                assertEquals(2, model.getResult());
                
                // try integer multiplication
                calculation = "6*7";
                controller.calculate(calculation);
                assertEquals(42, model.getResult());
                
                // try integer division
                calculation = "12/4";
                controller.calculate(calculation);
                assertEquals(3, model.getResult());
                
                // try bad calculation
                calculation = "25%7";
                try {
                        controller.calculate(calculation);
                        fail("expected exception");
                } catch (SyntaxException e) {
                        // expected
                }
        }

}
}}}

It should always be possible to test all behaviour of a `Controller` class with plain JUnit test cases, with some careful design and bit of mockery. Plain JUnit test cases are preferable to GWT test cases for unit testing, because they execute much faster.

=== Renderer ===

The next step in developing the application was to define the [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/widget/ModelListener.java ModelListener] interface and [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/widget/Renderer.java Renderer] class APIs. 

The `ModelListener` interface defines an API for any object interested in listening for changes to a `Model` object. Any implementation of the `ModelListener` interface can register itself as a listener of a `Model` object, and will then be notified of any changes to the properties of the `Model` object.

{{{
package examples.calculator.client.widget;

interface ModelListener {

        void onResultChanged(Double from, Double to);

}
}}}

The `Renderer` class implements the `ModelListener` interface, because it will listen to a `Model` instance and respond to any changes by updating some portion of the user-interface.

{{{
package examples.calculator.client.widget;

import com.google.gwt.event.dom.client.ClickEvent;
import com.google.gwt.event.dom.client.ClickHandler;
import com.google.gwt.user.client.Window;
import com.google.gwt.user.client.ui.Button;
import com.google.gwt.user.client.ui.HTML;
import com.google.gwt.user.client.ui.HorizontalPanel;
import com.google.gwt.user.client.ui.Label;
import com.google.gwt.user.client.ui.RootPanel;
import com.google.gwt.user.client.ui.TextBox;
import com.google.gwt.user.client.ui.VerticalPanel;

class Renderer implements ModelListener {

        private Label resultLabel = null;
        private Controller controller = null;
        private RootPanel rootPanel = null;
        private TextBox calculationTextBox;
        private Button calculateButton;

        Renderer() {}

        void setResultLabel(Label resultLabel) {
                this.resultLabel = resultLabel;
        }

        void setController(Controller controller) {
                this.controller = controller;
        }

        void setRootPanel(RootPanel rootPanel) {
                this.rootPanel = rootPanel;
        }

        void refresh() {
                if (rootPanel != null && controller != null) {
                        
                        // render main page elements
                        VerticalPanel p0 = new VerticalPanel();
                        rootPanel.add(p0);
                        p0.add(new HTML("<h1>Calculator</h1>"));
                        
                        HorizontalPanel p1 = new HorizontalPanel();
                        p0.add(p1);
                        p1.add(new Label("enter calculation (e.g., 31+11, 61-19, 6*7, 84/2):"));
                        calculationTextBox = new TextBox();
                        p1.add(calculationTextBox);
                        calculateButton = new Button("calculate!");
                        p1.add(calculateButton);
                        p1.setSpacing(5);

                        HorizontalPanel p2 = new HorizontalPanel();
                        p0.add(p2);
                        p2.add(new Label("result: "));
                        resultLabel = new Label();
                        p2.add(resultLabel);
                        p2.setSpacing(5);
                        
                        // set up event handlers
                        calculateButton.addClickHandler(new ClickHandler() {
                                public void onClick(ClickEvent event) {
                                        String calculation = calculationTextBox.getValue();
                                        try {
                                                controller.calculate(calculation);
                                        } catch (SyntaxException e) {
                                                Window.alert(e.getLocalizedMessage());
                                        }
                                }
                        });
                }
        }

        public void onResultChanged(Double from, Double to) {
                resultLabel.setText(to.toString());
        }

}
}}}

The `Renderer` class can also be developed test-first, although this usually requires GWT test cases, and hence can be slower. The class [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/widget/TestRenderer.java TestRenderer] illustrates a GWT test case for the `Renderer` class.

{{{
package examples.calculator.client.widget;

import com.google.gwt.junit.client.GWTTestCase;
import com.google.gwt.user.client.ui.Label;

public class TestRenderer extends GWTTestCase {

        @Override
        public String getModuleName() {
                return "examples.calculator.Calculator";
        }
        
        public void testOnResultChanged() {
                
                // setup testee
                Model model = new Model();
                Renderer testee = new Renderer();
                model.addListener(testee);
                Label resultLabel = new Label();
                testee.setResultLabel(resultLabel);
                
                // do stuff under test
                model.setResult(new Double(42.0));
                
                // check outcome
                assertEquals("42.0", resultLabel.getText());

        }

}
}}}

=== Widget ===

The [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/widget/CalculatorWidget.java CalculatorWidget] class ties everything together. In it's constructor, it instantiates a model, then a controller, then a renderer, and finally invokes the renderer's `refresh()` method to render the page content.

{{{
package examples.calculator.client.widget;

import com.google.gwt.user.client.ui.RootPanel;

public class CalculatorWidget {

        public CalculatorWidget() {
                
                Model model = new Model();
                Controller controller = new Controller(model);
                
                Renderer renderer = new Renderer();
                renderer.setController(controller);
                model.addListener(renderer);
                
                renderer.setRootPanel(RootPanel.get());
                renderer.refresh();
                
        }
}
}}}

=== EntryPoint ===

Finally, to complete the example, an [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/EntryPoint.java EntryPoint] is needed to instantiate the widget on module load.

{{{
package examples.calculator.client;

import examples.calculator.client.widget.CalculatorWidget;

public class EntryPoint implements com.google.gwt.core.client.EntryPoint {

        public void onModuleLoad() {

                CalculatorWidget calculator = new CalculatorWidget();

        }

}
}}}

=== Packaging and Visibility ===

Note that the `CalculatorWidget` class is the only public class in the `example.calculator.client.widget` package. All other classes, i.e., `Controller`, `Model`, `ModelListener` and `Renderer` are package private. This convention reinforces the notion that these classes are used as internal components of the user interface component, and do not need to be visible externally. 

=== Rules & Conventions ===

The pattern enforces the following rules:

  * Event handlers only ever invoke methods on a controller.
  * A controller only ever makes changes to a model.
  * A renderer listens to a model and makes changes to the view (i.e., the user-interface, the DOM).
  
If you follow the example above, it shouldn't be possible to violate these rules. You're violating these rules if, e.g.:

  * An event handler makes changes directly to a model, or to some portion of the view.
  * A controller has any presentation logic whatsoever, i.e., if a controller accesses or makes changes directly to any portion of the view (i.e., the DOM).
  * A renderer makes changes to the model, or invokes methods on a controller. 
  
Any of these will mean you lose the ability to use the testing strategies described above.

Note, however, that the renderer is responsible for instantiating event handlers, which require a reference to the controller, and hence the renderer must also keep a reference to the controller.
