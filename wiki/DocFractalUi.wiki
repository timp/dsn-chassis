#summary documentation of the Fractal UI MVC pattern and supporting GWT library.

= Fractal UI =

<wiki:toc/>

----
== Introduction ==

Fractal UI is a architectural pattern for developing pure client-side (i.e., in-browser) applications, with supporting libraries for GWT. The design goals for Fractal UI are:

  * to enable an application to be developed in small, bite-size pieces, that are not overly complex or mind-bendingly hard to understand
  * to enable an application to grow in complexity without becoming difficult to maintain, test or debug
  * to enable different components of the application to be cleanly encapsulated, so that different members of a development team can work on different components in parallel, without disrupting each other's code or creating a tangled mess
  * to provide a clean separation of concerns that enables fine-grained unit testing 
  * to enable as much as possible of the application to be developed test-first

The name "fractal" is tentatively chosen because it provides a loose metaphor for the pattern. A fractal is self-similar, in that each of its parts, when examined more closely, appears similar to the whole. 

The Fractal UI pattern defines a strict internal MVC architecture for each component of an application, including the application itself. Each user-interface component's internal MVC architecture follows a strict execution cycle whereby events generated by user-interaction with the browser's DOM are mapped by the component's *event handlers* onto method calls on a *controller*. The component's *controller* performs some action (e.g., fetching or updating data asynchronously) before updating the component's *model*. The component's *renderer* listens for changes to the *model* and updates the component's portion of the DOM (i.e., the component's *view*).

In addition to it's own internal MVC architecture, each user-interface component can also have nested user-interface components (children). Those nested components have the same internal MVC architecture, and can themselves have nested components. Messages can propagate both up and down the hierarchy of nested components, providing a framework for coordination of behaviour between several components. 

----
== Fractal UI Components - Internal MVC Architecture ==

The Fractal MVC pattern defines an internal architecture for each user-interface component in the application. Each component has a *controller*, a *model*, a *renderer* and a set of *event handlers*, in addition to some portion of the browser's DOM, which constitutes the component's *view*. 

The pattern also requires that execution flows in a strict cycle, beginning with events generated by user interaction with the browser's DOM (the *view*), which are received by *event handlers*, which invoke some method on the *controller*, which performs some action and updates the *model*. The *renderer* listens for changes to the *model*, and updates the DOM to reflect those changes. 

http://farm3.static.flickr.com/2556/3771234129_55121daf90_d.jpg

One of the main advantages of the pattern is that it allows isolation of different aspects of the widget's logic. For example, the controller's logic can be tested by invoking methods on the controller, then examining the state of the model. I.e., the controller's logic, which is independent of any presentation details, can be isolated. Similarly, the renderer's logic can be tested by changing the state of the model, then examining the state of specific user-interface elements.

By mandating that execution flows in the strict cycle described above, the pattern also avoids "spaghetti code" which becomes difficult to maintain as the complexity of a user-interface grows.

=== GWT Example: Calculator Widget ===

To illustrate the pattern with GWT, consider a very simple calculator application. The application itself is deployed at the following location:

  * [http://dsn-chassis.googlecode.com/svn/trunk/gwt/lib/war/examples/calculator.html example calculator application]
  
All of the source code for this application can be browsed from the following location:

  * [http://code.google.com/p/dsn-chassis/source/browse/#svn/trunk/gwt/lib/examples/examples/calculator browse calculator application source code]
  
==== Developing the Controller and Model ====

The first step in developing this application was to define the [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/widget/Controller.java Controller] and [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/widget/Model.java Model] APIs. 

The `Controller` class has a single `calculate` method, which parses a string as a simple arithmetic calculation (e.g., "61-19"), executes the calculation, and stores the result in a property called `result` on the `Model`. 

{{{
package examples.calculator.client.widget;

class Controller {
        
        private static final String ADDITION = "\\s*(\\d+)\\s*\\+\\s*(\\d+)\\s*";
        private static final String SUBTRACTION = "\\s*(\\d+)\\s*-\\s*(\\d+)\\s*";
        private static final String MULTIPLICATION = "\\s*(\\d+)\\s*\\*\\s*(\\d+)\\s*";
        private static final String DIVISION = "\\s*(\\d+)\\s*/\\s*(\\d+)\\s*";
        private static final String OPERATORS = "[+*/\\-]"; 
        private Model model;

        Controller(Model model) {
                this.model = model;
        }

        void calculate(String calculation) throws SyntaxException {

                Double result = null;

                String[] args = calculation.split(OPERATORS);
                
                if (calculation.matches(ADDITION)) {
                        result = Double.parseDouble(args[0]) + Double.parseDouble(args[1]);
                } 
                else if (calculation.matches(SUBTRACTION)) {
                        result = Double.parseDouble(args[0]) - Double.parseDouble(args[1]);
                }
                else if (calculation.matches(MULTIPLICATION)) {
                        result = Double.parseDouble(args[0]) * Double.parseDouble(args[1]);
                }
                else if (calculation.matches(DIVISION)) {
                        result = Double.parseDouble(args[0]) / Double.parseDouble(args[1]);
                }
                else {
                        throw new SyntaxException("invalid syntax: "+calculation);
                }
                
                model.setResult(result);
        }

}
}}}

The `Model` class is very much like a Bean, in the sense that it has a set of properties and getters and setters for those properties, but no other behaviour.

{{{
package examples.calculator.client.widget;

import java.util.ArrayList;
import java.util.List;

class Model {

        private Double result = null;
        private List<ModelListener> listeners = new ArrayList<ModelListener>();
       
        Double getResult() {
                return result;
        }

        void setResult(Double to) {
                Double from = this.result;
                this.result = to;
                for (ModelListener listener : listeners) {
                        listener.onResultChanged(from, to);
                }
        }
       
        void addListener(ModelListener listener) {
                listeners.add(listener);
        }

}
}}}

==== Testing the Controller ====

The `Controller` and `Model` classes can be developed test-first, using a plain JUnit test case. The class [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/widget/TestController.java TestController] illustrates a unit test for the `Controller.calculate()` method. 

{{{
package examples.calculator.client.widget;

import static org.junit.Assert.*;
import org.junit.Test;

public class TestController {

        @Test
        public void testCalculate() throws Exception {
                
                Model model = new Model();
                Controller controller = new Controller(model);
                
                // check initial state of model
                assertNull(model.getResult());
                
                String calculation;
                
                // try integer addition
                calculation = "2+4";
                controller.calculate(calculation);
                assertEquals(6, model.getResult());
                
                // try integer subtraction
                calculation = "5-3";
                controller.calculate(calculation);
                assertEquals(2, model.getResult());
                
                // try integer multiplication
                calculation = "6*7";
                controller.calculate(calculation);
                assertEquals(42, model.getResult());
                
                // try integer division
                calculation = "12/4";
                controller.calculate(calculation);
                assertEquals(3, model.getResult());
                
                // try bad calculation
                calculation = "25%7";
                try {
                        controller.calculate(calculation);
                        fail("expected exception");
                } catch (SyntaxException e) {
                        // expected
                }
        }

}
}}}

It should always be possible to test all behaviour of a `Controller` class with plain JUnit test cases, with some careful design and bit of mockery. Plain JUnit test cases are preferable to GWT test cases for unit testing, because they execute much faster.

==== Developing the Renderer as a !ModelListener ====

The next step in developing the application was to define the [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/widget/ModelListener.java ModelListener] interface and [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/widget/Renderer.java Renderer] class APIs. 

The `ModelListener` interface defines an API for any object interested in listening for changes to a `Model` object. Any implementation of the `ModelListener` interface can register itself as a listener of a `Model` object, and will then be notified of any changes to the properties of the `Model` object.

{{{
package examples.calculator.client.widget;

interface ModelListener {

        void onResultChanged(Double from, Double to);

}
}}}

The `Renderer` class implements the `ModelListener` interface, because it will listen to a `Model` instance and respond to any changes by updating some portion of the user-interface.

{{{
package examples.calculator.client.widget;

import com.google.gwt.event.dom.client.ClickEvent;
import com.google.gwt.event.dom.client.ClickHandler;
import com.google.gwt.user.client.Window;
import com.google.gwt.user.client.ui.Button;
import com.google.gwt.user.client.ui.HTML;
import com.google.gwt.user.client.ui.HorizontalPanel;
import com.google.gwt.user.client.ui.Label;
import com.google.gwt.user.client.ui.RootPanel;
import com.google.gwt.user.client.ui.TextBox;
import com.google.gwt.user.client.ui.VerticalPanel;

class Renderer implements ModelListener {

        private Label resultLabel = null;
        private Controller controller = null;
        private RootPanel rootPanel = null;
        private TextBox calculationTextBox;
        private Button calculateButton;

        Renderer() {}

        void setResultLabel(Label resultLabel) {
                this.resultLabel = resultLabel;
        }

        void setController(Controller controller) {
                this.controller = controller;
        }

        void setRootPanel(RootPanel rootPanel) {
                this.rootPanel = rootPanel;
        }

        void refresh() {
                if (rootPanel != null && controller != null) {
                        
                        // render main page elements
                        VerticalPanel p0 = new VerticalPanel();
                        rootPanel.add(p0);
                        p0.add(new HTML("<h1>Calculator</h1>"));
                        
                        HorizontalPanel p1 = new HorizontalPanel();
                        p0.add(p1);
                        p1.add(new Label("enter calculation (e.g., 31+11, 61-19, 6*7, 84/2):"));
                        calculationTextBox = new TextBox();
                        p1.add(calculationTextBox);
                        calculateButton = new Button("calculate!");
                        p1.add(calculateButton);
                        p1.setSpacing(5);

                        HorizontalPanel p2 = new HorizontalPanel();
                        p0.add(p2);
                        p2.add(new Label("result: "));
                        resultLabel = new Label();
                        p2.add(resultLabel);
                        p2.setSpacing(5);
                        
                        // set up event handlers
                        calculateButton.addClickHandler(new ClickHandler() {
                                public void onClick(ClickEvent event) {
                                        String calculation = calculationTextBox.getValue();
                                        try {
                                                controller.calculate(calculation);
                                        } catch (SyntaxException e) {
                                                Window.alert(e.getLocalizedMessage());
                                        }
                                }
                        });
                }
        }

        public void onResultChanged(Double from, Double to) {
                resultLabel.setText(to.toString());
        }

}
}}}

==== Testing the Renderer ====

The `Renderer` class can also be developed test-first, although this usually requires GWT test cases, and hence can be slower. The class [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/widget/TestRenderer.java TestRenderer] illustrates a GWT test case for the `Renderer` class.

{{{
package examples.calculator.client.widget;

import com.google.gwt.junit.client.GWTTestCase;
import com.google.gwt.user.client.ui.Label;

public class TestRenderer extends GWTTestCase {

        @Override
        public String getModuleName() {
                return "examples.calculator.Calculator";
        }
        
        public void testOnResultChanged() {
                
                // setup testee
                Model model = new Model();
                Renderer testee = new Renderer();
                model.addListener(testee);
                Label resultLabel = new Label();
                testee.setResultLabel(resultLabel);
                
                // do stuff under test
                model.setResult(new Double(42.0));
                
                // check outcome
                assertEquals("42.0", resultLabel.getText());

        }

}
}}}

==== The !CalculatorWidget ====

The [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/widget/CalculatorWidget.java CalculatorWidget] class ties everything together. In it's constructor, it instantiates a model, then a controller, then a renderer, and finally invokes the renderer's `refresh()` method to render the page content.

{{{
package examples.calculator.client.widget;

import com.google.gwt.user.client.ui.RootPanel;

public class CalculatorWidget {

        public CalculatorWidget() {
                
                Model model = new Model();
                Controller controller = new Controller(model);
                
                Renderer renderer = new Renderer();
                renderer.setController(controller);
                model.addListener(renderer);
                
                renderer.setRootPanel(RootPanel.get());
                renderer.refresh();
                
        }
}
}}}

==== An !EntryPoint ====

Finally, to complete the example, an [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/examples/examples/calculator/client/EntryPoint.java EntryPoint] is needed to instantiate the widget on module load.

{{{
package examples.calculator.client;

import examples.calculator.client.widget.CalculatorWidget;

public class EntryPoint implements com.google.gwt.core.client.EntryPoint {

        public void onModuleLoad() {

                CalculatorWidget calculator = new CalculatorWidget();

        }

}
}}}

=== Notes ===

==== Packaging and Visibility ====

Note in the example above that the `CalculatorWidget` class is the only public class in the `example.calculator.client.widget` package. All other classes, i.e., `Controller`, `Model`, `ModelListener` and `Renderer` are package private. This convention reinforces the notion that these classes are used as internal components of the user interface component, and do not need to be visible externally. 

==== Rules & Conventions ====

The pattern enforces the following rules:

  * Event handlers only ever invoke methods on a controller.
  * A controller only ever makes changes to a model.
  * A renderer listens to a model and makes changes to the view (i.e., the user-interface, the DOM).
  
If you follow the example above, it shouldn't be possible to violate these rules. You're violating these rules if, e.g.:

  * An event handler makes changes directly to a model, or to some portion of the view.
  * A controller has any presentation logic whatsoever, i.e., if a controller accesses or makes changes directly to any portion of the view (i.e., the DOM).
  * A renderer makes changes to the model, or invokes methods on a controller. 
  
Any of these will mean you lose the ability to use the testing strategies described above.

Note, however, that the renderer is responsible for instantiating event handlers, which require a reference to the controller, and hence the renderer must also keep a reference to the controller.

----
== Nesting Fractal UI Components ==

TODO add examples to this section

Typically, a user-interface application will involve a number of different user-interface components. The Fractal UI pattern allows each component to be designed, developed and tested in isolation. The pattern also allows a component to delegate some portion of its functionality to one or more nested components (a.k.a. children). 

Each user-interface component has an internal MVC architecture as described above, but that internal architecture is hidden from other components, both above (parents) and below (children) in the nested hierarchy. I.e., each user-interface component is a black box w.r.t. all other components.

In order to enable communication between parents and their children, each component exposes a regular API, that enables a parent component to instruct its children to perform specific actions. A component's regular API will typically be some subset of its controller's API, i.e., those controller methods that it is willing to expose to other components.

Each component may also expose a publish-subscribe API, that enables its parent to subscribe to and be notified of important events in its life cycle, such as a successful response to an asynchronous request.

The class [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/src/org/cggh/chassis/gwt/lib/ui/fractal/client/FractalUIComponent.java FractalUIComponent] in the GWT module `org.cggh.chassis.gwt.lib.ui.fractal.Fractal` provides some simple support for nesting of GWT user-interface components. Any user-interface component can extend the `FractalUIComponent` class, which provides methods for adding, removing and clearing child (nested) components.

It is recommended that all communication between components be handled between parent and their children only. I.e., it is not recommended that components be allowed to communicate with their siblings, or with other components not immediately above or below them in the nested hierarchy. It is also recommended that children only communicate passively with their parents, via the publish-subscribe API. I.e., children can notify their parents of important events, but do not invoke any methods of their parents regular API. This ensures that each component has clear and sole responsibility for coordinating the behaviour of its children. I.e., it is always clear where responsibility for coordinating behaviour between multiple components lies.

=== Nesting and History Management in GWT ===

The `FractalUIComponent` class also provides some support for managing the browser history, in the case where an application has an arbitrarily nested hierarchy of user-interface components. If each component extends the `FractalUIComponent` class, then any component at any point in the hierarchy can mark a `waypoint()` in the application's state, which will cause a new item to be added to the GWT History, encapsulating the complete state of the application at that time.

Each component of your application that extends the `FractalUIComponent` class is required to maintain a *state key*, which is a piece of data that is just sufficient to enable the component to reconstruct its current state from scratch, if required to do so (e.g., when a user clicks back or forward in the browser, or bookmarks the application). A component could of course store a representation of its complete internal state in the state key, however this is typically unecessary, and may be impractical considering that the state key must be serialised into a history token, which is appended to the current URL. Often one piece of information, such as a user's current search term in the case of a search results widget, is enough to enable the component to reconstruct its state. 

To enable state keys from an arbitrary hierarchy of nested components to be serialised into a single string that can act as a history token for the GWT History class, the `FractalUIComponent` class uses a JSON object to act as the component's state key. The component extending `FractalUIComponent` must implement the `syncStateKey()` method to synchronise the component's state key with whatever the component's current state is. When any component calls its own `waypoint()` method, that automatically triggers a call to the component's `syncStateKey()` method. An instruction to add a new item to the GWT History is then propagated up to the top of the component hierarchy, where all the state keys from all of the components in the hierarchy can be composed into a single history token.

To respond to history events, each component extending `FractalUIComponent` must also implement the `syncState()` method. This method should attempt to reconstruct the state of the application be accessing the state key, which will have been automatically populated from the updated history token. The method should also return a deferred value, and callback the deferred when it is ready for the history event to be propagated to its children. This gives each component a chance to rearrange it's children before a history event is propagated down the hierarchy.

The class [http://code.google.com/p/dsn-chassis/source/browse/trunk/gwt/lib/src/org/cggh/chassis/gwt/lib/ui/fractal/client/FractalUIHistoryManager.java FractalUIHistoryManager] is used to listen to history events. An instance of this class must be given a reference to the component that sits at the top of the nested component hierarchy. Any history events will be passed to this top component, which will automatically extract its state key and synchronise its state (via the `syncState()` method) before the event will be automatically propagated down the hierarchy to any nested components.

