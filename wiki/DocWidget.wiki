#summary documentation for the chassis widget framework

= Introduction =

This page provides some documentation and notes on the chassis widget framework for GWT.

= Widget Lifecycle -- !ChassisWidget =

The base class for the chassis widget framework is [http://code.google.com/p/dsn-chassis/source/browse/trunk/generic/lib/gwt/src/main/java/org/cggh/chassis/generic/widget/client/ChassisWidget.java ChassisWidget].

= Controller-Model-Renderer -- !DelegatingWidget =

A really simple (actually, the simplest possible) example of using the [http://code.google.com/p/dsn-chassis/source/browse/trunk/generic/lib/gwt/src/main/java/org/cggh/chassis/generic/widget/client/DelegatingWidget.java DelegatingWidget] (controller-model-renderer) pattern is the [http://code.google.com/p/dsn-chassis/source/browse/trunk/wwarn/ui/src/main/java/org/cggh/chassis/wwarn/ui/submitter/client/ViewStudyWidget.java ViewStudyWidget] and associated [http://code.google.com/p/dsn-chassis/source/browse/trunk/wwarn/ui/src/main/java/org/cggh/chassis/wwarn/ui/submitter/client/ViewStudyWidgetController.java ...Controller], [http://code.google.com/p/dsn-chassis/source/browse/trunk/wwarn/ui/src/main/java/org/cggh/chassis/wwarn/ui/submitter/client/ViewStudyWidgetModel.java ...Model] and [http://code.google.com/p/dsn-chassis/source/browse/trunk/wwarn/ui/src/main/java/org/cggh/chassis/wwarn/ui/submitter/client/ViewStudyWidgetRenderer.java ...Renderer] classes in the [http://code.google.com/p/dsn-chassis/source/browse/trunk/wwarn/ui/src/main/java/org/cggh/chassis/wwarn/ui/submitter/client/ org.cggh.chassis.wwarn.ui.submitter.client package]. I created that widget just to handle asynchronous lookup of the title of the currently selected study, given the study id. I'm not actually using it any more, but I'll leave it there as an example.

A more complicated example of using the [http://code.google.com/p/dsn-chassis/source/browse/trunk/generic/lib/gwt/src/main/java/org/cggh/chassis/generic/widget/client/DelegatingWidget.java DelegatingWidget] pattern is the current implementation of the [http://code.google.com/p/dsn-chassis/source/browse/trunk/wwarn/ui/src/main/java/org/cggh/chassis/wwarn/ui/submitter/client/UploadFilesWidget.java UploadFilesWidget] in the same package. That widget has a more complicated state machine, and it has to chain a couple of asynchronous calls, so it may look a bit hairy, but it's fundamentally the same idea ... the [http://code.google.com/p/dsn-chassis/source/browse/trunk/wwarn/ui/src/main/java/org/cggh/chassis/wwarn/ui/submitter/client/UploadFilesWidgetController.java Controller] takes some action (e.g., retrieves some data from a service), then updates the [http://code.google.com/p/dsn-chassis/source/browse/trunk/wwarn/ui/src/main/java/org/cggh/chassis/wwarn/ui/submitter/client/UploadFilesWidgetModel.java Model]. Whenever the [http://code.google.com/p/dsn-chassis/source/browse/trunk/wwarn/ui/src/main/java/org/cggh/chassis/wwarn/ui/submitter/client/UploadFilesWidgetModel.java Model] changes, it fires a [http://code.google.com/p/dsn-chassis/source/browse/trunk/generic/lib/gwt/src/main/java/org/cggh/chassis/generic/widget/client/ModelChangeEvent.java ModelChangeEvent]. The [http://code.google.com/p/dsn-chassis/source/browse/trunk/wwarn/ui/src/main/java/org/cggh/chassis/wwarn/ui/submitter/client/UploadFilesWidgetRenderer.java Renderer] registers handlers for all !ModelChangeEvents, which synchronise the user interface (the view) with the current state of the Model. The Renderer also has a syncUI method, which you can use to force a complete synchronisation of the user interface with the current state of the model.

As an aside, I also decided to have a go with the GWT 2 !UiBinder framework, so the !UploadFilesWidget illustrates how to use the chassis !DelegatingWidget pattern with the !UiBinder framework.

I've drawn the [http://www.flickr.com/photos/londonbonsaipurple/4271358580/sizes/l/ state diagram for the UploadFilesWidget] - that should help to make some sense of the widget, especially the controller and model. For each widget I design I usually start with  a state diagram. The states in the diagram then become constants in the ...Model class, to use as values of the Model's status field. The Renderer then uses changes to the Model's status field to determine which bits of the user interface should be visible at any time.

Here's another way of looking at the controller-model-renderer pattern ... The widget's Model holds the widget's data. I.e., the fields of the model class are where the widget stores its current state. The widget's Controller encapsulates the behaviour of the widget, it's state machine, independently from any presentation logic. The Renderer then encapsulates the presentation logic. Because you have separated the widget's state machine (Controller) from it's presentation logic (Renderer), you can then test the two independently, if you want to. It is also then very easy to implement a custom renderer to render the widget in a different way, if you want to do that, because the renderer is effectively pluggable. 