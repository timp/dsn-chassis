#summary documentation for the chassis async gwt library

= Deferred =

The chassis deferred class is a direct port of the Deferred class in the [http://mochikit.com/doc/html/MochiKit/Async.html MochiKit async library] - the Overview section of the [http://mochikit.com/doc/html/MochiKit/Async.html MochiKit Async docs] and the [http://mochikit.com/doc/html/MochiKit/Async.html#fn-deferred Deferred function documentation] will tell you almost all you need to know. The only things added after porting the code from !JavaScript to Java were generics so you can get a bit of type safety (but not too much!) and the adapt() method.

== Callback Chains ==

Note that there is no limit to the number of callback functions you can add to a Deferred object. Each callback you add is added to the callback chain for that Deferred. When the value becomes available, it is passed to the first callback in the chain. The return value from that callback is then passed to the next callback in the chain, and so on until the end of the chain.

E.g. ...

{{{
Deferred<Foo> deferredFoo = doAsyncFoo();
deferredFoo.addCallback(new Function<Foo, Bar>() {
    public Bar apply(Foo foo) {
        Bar bar = foo2bar(foo);
        return bar;
    }
});
deferredFoo.addCallback(new Function<Bar, Baz>() {
    public Baz apply(Bar bar) {
        Baz baz = bar2baz(bar);
        return baz;
    }
};
// and so on ...
}}}

Note that there is no generic type constraint on the function passed as an argument to addCallback() ... you can add a function with any type signiature you want. It is up to you to make sure that the input and output types make sense for the callback chain you want to use. If the input and output types in a callback chain are not compatible, then an error will be passed to the next errback function in the chain.

Most often, a callback will simply return the input value. This makes that value available to any other callbacks that are added

E.g. ...

{{{
Deferred<Foo> deferredFoo = doAsyncFoo();
deferredFoo.addCallback(new Function<Foo, Foo>() {
    public Foo apply(Foo foo) {

        doSomethingWithFoo(foo);

        // return foo in case any other callbacks are interested
        return foo;
    }
});
}}}

... this means you can handle the result of the async operation in one place, but also pass the deferred object to other parts of your application if they also need to handle the result of the async operation.

Returning null from a callback is generally not polite, unless you specifically want to prevent any further callbacks from being added to a deferred object.

== Callbacks and Errbacks ==

It's worth reading the [http://mochikit.com/doc/html/MochiKit/Async.html#fn-deferred Deferred function documentation] carefully. If you do, you'll discover if you start with ...

{{{
Deferred<Foo> deferredFoo = doAsyncFoo();
Function<Foo, Foo> callback = new Function<Foo, Foo>() {
    public Foo apply(Foo foo) {
        doSomething(foo);
        return foo;
    }
};
Function<Throwable, Throwable> errback = new Function<Throwable, Throwable>() {
    public Throwable apply(Throwable in) {
        handleError(in);
        return in;
    }
};
}}}

... that doing ...

{{{
deferredFoo.addCallbacks(callback, errback);
}}}

... is different from doing ...

{{{
deferredFoo.addCallback(callback);
deferredFoo.addErrback(errback);
}}}

If `deferredFoo.errback(anException)` is called, both cases will behave the same - the `errback` function is called.

The difference will arise if the `callback` function itself throws an exception during execution. If it does, in the second case, the exception will be passed to the `errback` function. In the first case, the exception *will not* be passed to the `errback` function.

Usually, I use the second pattern, and write the `errback` function to cope with either an exception passed via a call to errback() on the deferred, or an exception thrown from the callback.

If you use the first pattern, make sure you're callback function does its own error handling. If it doesn't, and throws an exception, then the deferred object will catch that for you, and pass it on to any subsequent errbacks you add, but will otherwise sit there silently in an error state.

If you suspect this is the case, enable logging for the async module - any exceptions are logged.

== Chaining Async Operations ==

If you have two async operations to perform, and they have to happen in sequence, then you can do one of two things.

Either ...

{{{
Deferred<Foo> deferredFoo = doAsyncFoo();
deferredFoo.addCallback(new Function<Foo, Foo>() {
    public Foo apply(Foo foo) {
        Deferred<Bar> deferredBar = doAsyncBar(foo);
        deferredBar.addCallback(new Function<Bar, Bar>() {
            public Bar apply(Bar bar) {
                // do something with bar, now you've got it
                return bar;
            }
        });
        return foo;
    }
});
}}}

... or ...

{{{
Deferred<Foo> chain = doAsyncFoo();
chain.addCallback(new Function<Foo, Deferred<Bar>>() {
    public Deferred<Bar> apply(Foo foo) {
        return doAsyncBar(foo);
    }
});
chain.addCallback(new Function<Bar, Bar>() {
    public Bar apply(Bar bar) {
        // do something with bar, now you've got it
        return bar;
    }
});
}}}

Note that, in the second way, you make use of the fact that, if a callback function returns a Deferred object, then the callbacks will be automatically chained for you, such that then next callback in the chain is only called after the Deferred value returned by the previous callback becomes available, and is called back with that value, and not with the Deferred. 

I.e., the implementation of the Deferred class specifically looks out for callbacks returning an instance of Deferred, and handles it in a special way, not in the normal way of simply passing the return value from the first callback as the input to the next callback in the chain.